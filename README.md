# Тестовое задание на позицию Product Data Analyst в Happy Games Studio  

Добро пожаловать! Здесь вы можете ознакомится с текстом задания и этапами его выполнения, разделенными на создание таблиц, их заполнение, а также решение задач.
В корне репозитория находятся все необходимые скрипты, а дамп базы данных лежит в папке dump.  
  
## Текст задания
Для выполнения данного задания предлагается использовать следующую структуру данных:

●	Таблица "users" с полями: id, name, email, created_at  
●	Таблица "orders" с полями: id, user_id, total_price, created_at  
●	Таблица "order_items" с полями: id, order_id, product_name, price, quantity  

В ответе пришлите имя и версию используемой бд, дамп структуры базы, а также запросы для заполнения тестовыми данными, в работе строк должно быть не менее 1 млн в каждой таблице.  
Ответ должен представлять из себя SQL запрос с пояснением. По желанию можете дополнить ваш ответ плохим вариантом запроса также с объяснением.  

Запросы:  
1.	Найти общее количество заказов каждого пользователя, который сделал более 10 заказов.  
2.	Найти средний размер заказа для каждого пользователя за последний месяц.  
3.	Найти средний размер заказа за каждый месяц в текущем году и сравнить его с средним размером заказа за соответствующий месяц в прошлом году.  
4.	Найти 10 пользователей, у которых наибольшее количество заказов за последний год, и для каждого из них найти средний размер заказа за последний месяц.  

## Ход выполнения  

 ### 1. Создание базы данных и таблиц  
 
Работу выполнял в MySQL 8.0.27, использовал MySQL Workbench 8.0  
Сначала создал базу данных CREATE DATABASE, затем переключился на нее.
Затем создал таблицы, используя скрипт, находящийся в файле create_tables.sql.
Так как создавал тестовый вариант, не учел возможность добавления новых записей, то есть не добавил default значение для created_at. Это исправляется следующими командами:  
*ALTER TABLE users MODIFY created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP*;  
*ALTER TABLE orders MODIFY created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP*;  

### 2. Заполнение таблиц данными  

* Для этого использовал скрипты, находящиеся в файлах create_seq10^6.sql, users_insert.sql, orders_insert.sql, order_items_insert.sql.  
Скрипт create_seq10^6.sql нужен для того, чтобы создать вспомогательную таблицу, содержащую миллион строк.  
Её использовал при создании всех остальных таблиц. 
* В таблице users создано 10^6 уникальных пользователей с уникальными именами и email'ами. Доменное имя электронной почты у всех одинаковое, как и дата создания (3 года назад), так как эти данные не влияют на результат выполнения тестовых задач.  
* В таблице orders создано 2x10^6 уникальных заказов, total_price которых лежит в диапозоне от 10000000 до 5000. Да, числа большие, но ведь хорошо, когда много покупают :)  
Поле created_at задал случайным значением в диапазоне от текущей даты (14.04.2023) до двух лет назад, чтобы наибольшее число значений было использовано при решении задач.  
Поле id, к сожалению, не принимает значения по порядку от 1 до 2x10^6, так как заполнял таблицу, дважды использовав скрипт orders_insert.sql. При использовании функции RAND() для генерации случайных значений, для id, порядок добавления строк в таблицу не гарантируется, поэтому новые id могут присваиваться в произвольном порядке. Скрипт запускал дважды, так как обработать 2 миллиона строк за один запрос мой ноутбук не потянул, а около пяти переброванных способов из гугла не принесли пользы.  
* В таблице order_items в связи с вышеописанными трудностями пришлось применить GROUP BY RAND() и MIN(id) AS order_id, чтобы успешно реализовать foreign key. Кроме того, значения в этой таблице не совсем сочетаются с таблицей orders. Можно было бы написать несколько функций в python для заполнения данными таким образом, чтобы всё друг другу соответствовало, но для решения поставленных задач такой необходимости не возникло.  

### 3. Решение задач  

Решения представлены в файлах task_{n}.sql, где n=[1,2,3,4] соответственно.  

Первые две задачи довольно просты, уверен, что в пояснениях не нуждаются.  

Третья задача. Найти средний размер заказа за каждый месяц в текущем году и сравнить его с средним размером заказа за соответствующий месяц в прошлом году.  

Решал следующим образом. Используя CTE, создал cur12month и prev12month.
cur12month считает средние значения total_price за каждый из последних 12 месяцев (включая текущий), 
а также нзвание месяца и соответствующий год. prev12month считает то же самое, 
только с дополнительным лагом в 12 месяцев - то есть рассмотрены даты от 12 месяцев назад, до 24 месяцев назад. Месяцы упорядочены в хронологическом порядке, то есть апрель 2023 и 2022 года первый, май 2022 и 2021 последний.
Рассчитана разница между соответствующими показателями размеров продаж, для каждого месяца из актуального года вычитался предыдущий.  
Пробовал ускорить работу скрипта индексом по created_at, но ощутимых результатов не принесло из-за высокой кардинальности значений дат.  

Четвертая задача. Найти 10 пользователей, у которых наибольшее количество заказов за последний год, и для каждого из них найти средний размер заказа за последний месяц.  

В условии WHERE отбираем пользователей, совершивших заказ за последний год, группируем по всем таким пользователям, сортируем по количеству заказов в ORDER BY, оставляем первых десятерых из них в условии LIMIT.  
Основное действие - подсчет их среднего размера заказов - происходит в операторе select в условном выражении CASE. Если заказ был создан в последний месяц, то возвращается значение поля *total_price* этого заказа. В противном случае, т.е. если заказ был создан ранее, то возвращается значение NULL, т.к. после ключевого слова END нет никакого значения.  
Выражение *o.created_at >= DATE_SUB(LAST_DAY(NOW() - INTERVAL 1 MONTH), INTERVAL 1 MONTH)* отбирает *created_at*, лежащий в диапазоне дат предыдщего месяца. То есть, если сегодня 14 апреля, мы получим данные продаж за март - последний завершенный месяц. Здесь, задачу можно трактовать по разному. Если интересуют даты с текущего дня до первого числа текущего месяца, можно заменить указанную строчку на *o.created_at >= DATE_FORMAT(NOW(), '%Y-%m-01')*. А если интересуют даты лежащие, в диапозоне 30 дней начиная с текущего, то можно заменить на *o.created_at >= DATE_SUB(NOW(), INTERVAL 1 MONTH)*.  
В моем основном варианте получилось три значения Null, то есть из десяти клентов, покупавших за последний год чаще остальных, трое ничего не покупали в марте.

На этом всё, прошу прощения за большой объем текста и спасибо за внимание.


  


